import 'dart:async';
import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path/path.dart' as p;
import 'package:wind_send/utils/utils.dart' as file_utils;

part 'database.g.dart';

/// Transfer type enum matching the integer type field in the database.
enum TransferType {
  text(0),
  file(1),
  image(2),
  batch(3);

  final int value;
  const TransferType(this.value);

  static TransferType fromValue(int value) {
    return TransferType.values.firstWhere(
      (e) => e.value == value,
      orElse: () => TransferType.text,
    );
  }
}

/// Transfer history table storing all transfer records.
///
/// Design notes:
/// - `pinOrder` uses REAL (float) to support middle insertion without reordering
/// - `textPayload` stores text ≤4MB; larger text uses `payloadPath`
/// - `payloadBlob` stores binary data <100KB; larger uses `payloadPath`
/// - `filesJson` stores file list as JSON for batch/file transfers
@DataClassName('TransferHistoryEntry')
class TransferHistory extends Table {
  /// Auto-incrementing primary key
  IntColumn get id => integer().autoIncrement()();

  /// Whether this item is pinned to top
  BoolColumn get isPinned => boolean().withDefault(const Constant(false))();

  /// Pin order for sorting pinned items.
  /// Uses REAL (float) to support middle insertion (e.g., insert 1.5 between 1.0 and 2.0).
  /// When max value exceeds threshold (e.g., 10000), should be recompacted to 1.0, 2.0, 3.0...
  RealColumn get pinOrder => real().nullable()();

  /// Timestamp when this transfer was created
  DateTimeColumn get createdAt => dateTime()();

  /// Source device ID
  TextColumn get fromDeviceId => text().nullable()();

  /// Destination device ID
  TextColumn get toDeviceId => text().nullable()();

  /// Direction: true = outgoing (I sent), false = incoming (I received)
  BoolColumn get isOutgoing => boolean()();

  /// Transfer type as integer (see TransferType enum)
  IntColumn get type => integer()();

  /// Data size in bytes
  IntColumn get dataSize => integer().withDefault(const Constant(0))();

  /// Text content for text transfers (≤4MB).
  /// For larger text, stores first 500 chars as preview and full content in payloadPath.
  TextColumn get textPayload => text().nullable()();

  /// JSON representation of file list for file/batch transfers.
  /// Structure: {"files": [...], "totalSize": N, "thumbnailPath": "..."}
  TextColumn get filesJson => text().nullable()();

  /// Path to large payload file (text >4MB or binary ≥100KB)
  TextColumn get payloadPath => text().nullable()();

  /// Small binary data (<100KB) stored directly in database
  BlobColumn get payloadBlob => blob().nullable()();

  @override
  List<Set<Column>> get uniqueKeys => [];

  @override
  List<String> get customConstraints => [];
}

/// Custom index definitions for transfer_history table.
/// Drift generates these as CREATE INDEX statements.
@DriftDatabase(tables: [TransferHistory])
class AppDatabase extends _$AppDatabase {
  /// Private constructor for singleton pattern
  AppDatabase._() : super(_openConnection());

  /// Singleton instance
  static AppDatabase? _instance;

  /// Completer for tracking initialization to prevent race conditions
  static Completer<AppDatabase>? _initCompleter;

  /// Get the singleton database instance.
  /// Creates the database on first access with integrity check.
  /// Thread-safe: uses Completer to ensure only one initialization happens.
  static Future<AppDatabase> getInstance() async {
    if (_instance != null) return _instance!;

    // If initialization is already in progress, wait for it
    if (_initCompleter != null) {
      return await _initCompleter!.future;
    }

    // Start initialization
    _initCompleter = Completer<AppDatabase>();
    try {
      _instance = AppDatabase._();

      // Perform integrity check on first access
      await _instance!._performIntegrityCheck();

      _initCompleter!.complete(_instance!);
      return _instance!;
    } catch (e) {
      _initCompleter!.completeError(e);
      _initCompleter = null;
      _instance = null;
      rethrow;
    }
  }

  /// Current schema version. Increment when making schema changes.
  @override
  int get schemaVersion => 1;

  /// Migration strategy for schema version management.
  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (Migrator m) async {
      // Create all tables on first run
      await m.createAll();

      // Create custom indexes not automatically generated by Drift
      await _createIndexes(m);
    },
    onUpgrade: (Migrator m, int from, int to) async {
      // Future migrations go here
      // Example:
      // if (from < 2) {
      //   await m.addColumn(transferHistory, transferHistory.newColumn);
      // }
    },
    beforeOpen: (details) async {
      // Enable foreign key constraints (good practice for data integrity)
      await customStatement('PRAGMA foreign_keys = ON');
    },
  );

  /// Create custom indexes for optimized queries.
  Future<void> _createIndexes(Migrator m) async {
    // Index for time-based queries (most common: recent history)
    await customStatement('''
      CREATE INDEX IF NOT EXISTS idx_transfer_history_created_at 
      ON transfer_history (created_at DESC)
    ''');

    // Index for type filtering
    await customStatement('''
      CREATE INDEX IF NOT EXISTS idx_transfer_history_type 
      ON transfer_history (type)
    ''');

    // Index for device filtering
    await customStatement('''
      CREATE INDEX IF NOT EXISTS idx_transfer_history_from_device 
      ON transfer_history (from_device_id)
    ''');

    // Composite index for pinned items sorting
    // Pinned items sorted by pin_order descending for display
    await customStatement('''
      CREATE INDEX IF NOT EXISTS idx_transfer_history_pinned 
      ON transfer_history (is_pinned, pin_order DESC)
    ''');
  }

  /// Perform database integrity check.
  /// If corruption is detected, backs up the corrupted file and creates a new database.
  Future<void> _performIntegrityCheck() async {
    try {
      final result = await customSelect('PRAGMA integrity_check').get();
      // SQLite's integrity_check returns rows with a single column containing the result string
      // If result is empty or contains any row that is not 'ok', database is corrupted
      // Multiple rows indicate multiple errors (each row is an error message)
      if (result.isEmpty) {
        await _handleCorruptedDatabase();
        return;
      }

      // Check the first column value (could be 'integrity_check' or column index 0)
      final resultValue =
          result.first.data['integrity_check'] ??
          result.first.data.values.first?.toString() ??
          '';
      if (resultValue != 'ok' || result.length > 1) {
        // If not 'ok' or multiple rows (errors), database is corrupted
        await _handleCorruptedDatabase();
      }
    } catch (e) {
      // If we can't even run the integrity check, database might be severely corrupted
      await _handleCorruptedDatabase();
    }
  }

  /// Handle corrupted database by backing up and recreating.
  Future<void> _handleCorruptedDatabase() async {
    final dbFile = await _getDatabaseFile();
    if (await dbFile.exists()) {
      // Create backup with timestamp
      final backupPath =
          '${dbFile.path}.corrupted.${DateTime.now().millisecondsSinceEpoch}';
      try {
        await dbFile.copy(backupPath);
        await dbFile.delete();
      } catch (e) {
        // If backup fails, just try to delete and recreate
        try {
          await dbFile.delete();
        } catch (_) {
          // Ignore deletion errors
        }
      }
    }

    // Close current connection and reset singleton to allow proper reinitialization
    try {
      await close();
    } catch (_) {
      // Ignore close errors if connection is already broken
    }
    _instance = null;
    _initCompleter = null;
    // Next call to getInstance() will recreate the database properly
  }

  /// Get recent transfer history with pagination.
  ///
  /// Returns items ordered by: pinned items first (by pin_order DESC),
  /// then non-pinned items by created_at DESC.
  Future<List<TransferHistoryEntry>> getRecentHistory({
    int limit = 20,
    int offset = 0,
    TransferType? typeFilter,
    String? deviceIdFilter,
  }) async {
    try {
      var query = select(transferHistory);

      if (typeFilter != null) {
        query = query..where((t) => t.type.equals(typeFilter.value));
      }

      if (deviceIdFilter != null) {
        query = query
          ..where(
            (t) =>
                t.fromDeviceId.equals(deviceIdFilter) |
                t.toDeviceId.equals(deviceIdFilter),
          );
      }

      // Order: pinned first (by pin_order DESC), then by created_at DESC
      query = query
        ..orderBy([
          (t) => OrderingTerm(expression: t.isPinned, mode: OrderingMode.desc),
          (t) => OrderingTerm(expression: t.pinOrder, mode: OrderingMode.desc),
          (t) => OrderingTerm(expression: t.createdAt, mode: OrderingMode.desc),
        ])
        ..limit(limit, offset: offset);

      return query.get();
    } catch (e) {
      // Log error and return empty list to prevent crashes
      // Callers should handle empty results gracefully
      return [];
    }
  }

  /// Get pinned items only, ordered by pin_order DESC.
  Future<List<TransferHistoryEntry>> getPinnedItems() async {
    try {
      return (select(transferHistory)
            ..where((t) => t.isPinned.equals(true))
            ..orderBy([
              (t) =>
                  OrderingTerm(expression: t.pinOrder, mode: OrderingMode.desc),
            ]))
          .get();
    } catch (e) {
      // Log error and return empty list to prevent crashes
      return [];
    }
  }

  /// Get the maximum pin_order value among pinned items.
  /// Returns 0.0 if no pinned items exist.
  Future<double> getMaxPinOrder() async {
    final result = await customSelect(
      'SELECT MAX(pin_order) as max_order FROM transfer_history WHERE is_pinned = 1',
    ).getSingleOrNull();

    return (result?.data['max_order'] as num?)?.toDouble() ?? 0.0;
  }

  /// Toggle pin status for an item.
  /// When pinning, assigns the next available pin_order.
  /// When unpinning, clears the pin_order.
  Future<void> togglePin(int id, bool pin) async {
    if (pin) {
      final maxOrder = await getMaxPinOrder();
      await (update(transferHistory)..where((t) => t.id.equals(id))).write(
        TransferHistoryCompanion(
          isPinned: const Value(true),
          pinOrder: Value(maxOrder + 1.0),
        ),
      );
    } else {
      await (update(transferHistory)..where((t) => t.id.equals(id))).write(
        const TransferHistoryCompanion(
          isPinned: Value(false),
          pinOrder: Value(null),
        ),
      );
    }
  }

  /// Recompact pin_order values when they exceed threshold.
  /// Call this periodically or when max pin_order > 10000.
  Future<void> recompactPinOrders() async {
    final pinnedItems = await getPinnedItems();
    if (pinnedItems.isEmpty) return;

    await transaction(() async {
      for (var i = 0; i < pinnedItems.length; i++) {
        await (update(
          transferHistory,
        )..where((t) => t.id.equals(pinnedItems[i].id))).write(
          TransferHistoryCompanion(pinOrder: Value((i + 1).toDouble())),
        );
      }
    });
  }

  /// Insert a new transfer history entry.
  Future<int> insertHistory(TransferHistoryCompanion entry) async {
    return into(transferHistory).insert(entry);
  }

  /// Delete a transfer history entry by ID.
  Future<int> deleteHistory(int id) async {
    return (delete(transferHistory)..where((t) => t.id.equals(id))).go();
  }

  /// Delete multiple entries by IDs.
  Future<int> deleteHistories(List<int> ids) async {
    return (delete(transferHistory)..where((t) => t.id.isIn(ids))).go();
  }

  /// Delete entries older than specified date (except pinned items).
  Future<int> deleteOlderThan(DateTime date) async {
    return (delete(transferHistory)..where(
          (t) => t.createdAt.isSmallerThanValue(date) & t.isPinned.not(),
        ))
        .go();
  }

  /// Delete oldest entries when count exceeds limit (except pinned items).
  /// Returns the number of deleted entries.
  Future<int> deleteExcessEntries(int maxCount) async {
    // First, count non-pinned entries
    final countResult = await customSelect(
      'SELECT COUNT(*) as cnt FROM transfer_history WHERE is_pinned = 0',
    ).getSingle();
    final currentCount = countResult.data['cnt'] as int;

    if (currentCount <= maxCount) return 0;

    final toDelete = currentCount - maxCount;

    // Delete oldest non-pinned entries
    await customStatement(
      '''
      DELETE FROM transfer_history 
      WHERE id IN (
        SELECT id FROM transfer_history 
        WHERE is_pinned = 0 
        ORDER BY created_at ASC 
        LIMIT ?
      )
    ''',
      [toDelete],
    );

    return toDelete;
  }

  /// Search history entries by text content.
  Future<List<TransferHistoryEntry>> searchHistory(
    String query, {
    int limit = 50,
  }) async {
    try {
      final searchPattern = '%$query%';
      return (select(transferHistory)
            ..where(
              (t) =>
                  t.textPayload.like(searchPattern) |
                  t.filesJson.like(searchPattern),
            )
            ..orderBy([
              (t) => OrderingTerm(
                expression: t.createdAt,
                mode: OrderingMode.desc,
              ),
            ])
            ..limit(limit))
          .get();
    } catch (e) {
      // Log error and return empty list to prevent crashes
      return [];
    }
  }

  /// Get all payload paths for cleanup purposes.
  /// Returns paths that are referenced in the database.
  Future<List<String>> getAllPayloadPaths() async {
    final results = await customSelect(
      'SELECT DISTINCT payload_path FROM transfer_history WHERE payload_path IS NOT NULL',
    ).get();
    return results
        .map((r) => r.data['payload_path'] as String?)
        .whereType<String>()
        .toList();
  }

  /// Close the database connection.
  ///
  /// **Important:** This method should be called during app lifecycle events
  /// (e.g., in `WidgetsBindingObserver.didChangeAppLifecycleState` when app
  /// goes to background or terminates) to ensure proper cleanup and prevent
  /// data corruption. The database will be automatically reopened on next access.
  Future<void> closeDatabase() async {
    await close();
    _instance = null;
    _initCompleter = null;
  }
}

/// Get the database file path.
Future<File> _getDatabaseFile() async {
  final historyStoragePath = await file_utils.getHistoryStoragePath();
  return File(p.join(historyStoragePath, 'transfer_history.db'));
}

/// Open connection to the SQLite database.
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    final file = await _getDatabaseFile();

    // Ensure directory exists
    final dir = file.parent;
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }

    return NativeDatabase.createInBackground(file);
  });
}
